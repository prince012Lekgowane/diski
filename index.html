<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kele vs Lele - 3D Soccer Showdown</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            overflow: hidden;
            color: white;
            touch-action: none;
        }
        
        #game-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        /* MENU SCREENS */
        .menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            z-index: 1000;
            padding: 20px;
            overflow-y: auto;
        }
        
        .menu-screen.hidden { display: none; }
        
        .menu-title {
            font-size: clamp(28px, 6vw, 48px);
            font-weight: bold;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }
        
        .menu-subtitle {
            font-size: clamp(14px, 3vw, 20px);
            color: #aaa;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .mode-selection {
            display: flex;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .mode-card {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 15px;
            padding: 25px;
            width: 240px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .mode-card:hover {
            transform: translateY(-5px);
            border-color: #FFD700;
        }
        
        .mode-card.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.15);
            transform: scale(1.05);
        }
        
        .mode-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .mode-name {
            font-size: 22px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        
        .mode-desc {
            font-size: 14px;
            color: #bbb;
        }
        
        .team-selection {
            display: flex;
            gap: 20px;
            margin: 30px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .team-card {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid transparent;
            border-radius: 20px;
            padding: 25px;
            width: clamp(220px, 40vw, 280px);
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .team-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .team-card.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.1);
            transform: scale(1.05);
        }
        
        .team-card.pirates { border-color: #333; }
        .team-card.pirates.selected { border-color: #FFD700; background: rgba(0, 0, 0, 0.3); }
        
        .team-card.sundowns { border-color: #FFD700; }
        .team-card.sundowns.selected { background: rgba(255, 215, 0, 0.2); }
        
        .team-logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            font-weight: bold;
        }
        
        .pirates .team-logo {
            background: linear-gradient(135deg, #000 0%, #333 100%);
            border: 3px solid #FFD700;
        }
        
        .sundowns .team-logo {
            background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
            color: #000;
        }
        
        .team-name {
            font-size: clamp(20px, 4vw, 28px);
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .team-player {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 15px;
        }
        
        .team-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #FFD700;
        }
        
        .stat-label {
            font-size: 11px;
            color: #888;
        }
        
        .menu-btn {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border: none;
            padding: 15px 40px;
            font-size: clamp(16px, 3vw, 20px);
            font-weight: bold;
            color: #000;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 15px;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.4);
        }
        
        .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.6);
        }
        
        .menu-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .room-input {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #FFD700;
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 18px;
            text-align: center;
            margin: 20px 0;
            width: 100%;
            max-width: 300px;
        }
        
        .room-code-display {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #FFD700;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
        }
        
        .room-code-display h3 {
            color: #FFD700;
            margin-bottom: 10px;
        }
        
        .room-code {
            font-size: 32px;
            font-weight: bold;
            color: white;
            letter-spacing: 5px;
        }
        
        .waiting-message {
            font-size: 18px;
            color: #aaa;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        /* INSTRUCTIONS */
        .instructions-content {
            max-width: 800px;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(20px, 4vw, 40px);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .instruction-section {
            margin: 25px 0;
        }
        
        .instruction-section h3 {
            color: #FFD700;
            font-size: clamp(18px, 3vw, 24px);
            margin-bottom: 15px;
        }
        
        .instruction-item {
            display: flex;
            align-items: center;
            margin: 12px 0;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        .instruction-key {
            background: #FFD700;
            color: #000;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            margin-right: 15px;
            min-width: 70px;
            text-align: center;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        .instruction-desc {
            flex: 1;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        /* GAME UI */
        #ui {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: clamp(10px, 2vw, 20px);
            border-radius: 15px;
            border: 3px solid #FFD700;
            backdrop-filter: blur(10px);
            z-index: 100;
            text-align: center;
            min-width: clamp(200px, 40vw, 300px);
        }
        
        #score {
            font-size: clamp(18px, 4vw, 32px);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .score-team {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 8px;
            margin: 0 5px;
        }
        
        .score-pirates {
            background: linear-gradient(45deg, #000, #333);
            border: 2px solid #FFD700;
        }
        
        .score-sundowns {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            color: #000;
        }
        
        #time {
            font-size: clamp(14px, 3vw, 18px);
            color: #FFD700;
            font-weight: bold;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }
        
        .control-group {
            display: flex;
            gap: 15px;
        }
        
        .joystick-area {
            width: clamp(100px, 20vw, 140px);
            height: clamp(100px, 20vw, 140px);
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 3px solid #FFD700;
            position: relative;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }
        
        .joystick {
            width: 50%;
            height: 50%;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            touch-action: none;
        }
        
        .action-btn {
            width: clamp(70px, 15vw, 90px);
            height: clamp(70px, 15vw, 90px);
            border-radius: 50%;
            background: linear-gradient(45deg, #ff3838, #ff0000);
            border: 3px solid #FFD700;
            color: white;
            font-weight: bold;
            font-size: clamp(12px, 2.5vw, 16px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 30px rgba(255, 56, 56, 0.5);
            transition: transform 0.1s;
            user-select: none;
            touch-action: none;
        }
        
        .action-btn:active {
            transform: scale(0.9);
        }
        
        #power-bar {
            position: absolute;
            bottom: clamp(180px, 30vh, 220px);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 250px);
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            border: 2px solid #FFD700;
            overflow: hidden;
            display: none;
        }
        
        #power-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffaa00, #ff0000);
            width: 0%;
            transition: width 0.05s;
        }
        
        #goal-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: clamp(32px, 8vw, 64px);
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 40px rgba(255, 215, 0, 0.9);
            z-index: 1000;
            transition: transform 0.3s;
            padding: clamp(15px, 3vw, 30px);
            border-radius: 20px;
            background-color: rgba(0, 0, 0, 0.9);
            border: 3px solid #FFD700;
            white-space: nowrap;
        }
        
        #stamina-bar {
            position: absolute;
            bottom: clamp(10px, 2vh, 20px);
            left: 50%;
            transform: translateX(-50%);
            width: clamp(150px, 30vw, 200px);
            text-align: center;
        }
        
        .stamina-label {
            font-size: clamp(11px, 2vw, 14px);
            color: #FFD700;
            margin-bottom: 5px;
        }
        
        .stamina-bg {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            border: 1px solid #FFD700;
            overflow: hidden;
        }
        
        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffaa00, #00ff00);
            width: 100%;
            transition: width 0.3s;
        }
        
        .pause-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: clamp(8px, 1.5vw, 10px) clamp(12px, 2vw, 20px);
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            z-index: 100;
            font-size: clamp(12px, 2vw, 14px);
        }
        
        #camera-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: clamp(8px, 1.5vw, 10px) clamp(12px, 2vw, 20px);
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            z-index: 100;
            font-size: clamp(12px, 2vw, 14px);
            display: none;
        }
        
        @media (max-width: 768px) {
            .team-selection { gap: 15px; }
            .instruction-item { 
                flex-direction: column; 
                text-align: center; 
                padding: 10px;
            }
            .instruction-key { margin: 0 0 10px 0; }
        }
        
        @media (max-height: 600px) {
            .menu-screen { justify-content: flex-start; padding-top: 20px; }
            .menu-title { font-size: 24px; margin-bottom: 10px; }
            .menu-subtitle { font-size: 14px; margin-bottom: 15px; }
        }
    </style>
</head>
<body>
    <!-- MODE SELECTION SCREEN -->
    <div id="mode-selection" class="menu-screen">
        <h1 class="menu-title">‚öΩ KELE vs LELE ‚öΩ</h1>
        <p class="menu-subtitle">Choose Your Game Mode</p>
        
        <div class="mode-selection">
            <div class="mode-card" data-mode="single">
                <div class="mode-icon">ü§ñ</div>
                <div class="mode-name">VS AI</div>
                <div class="mode-desc">Play against computer opponent</div>
            </div>
            
            <div class="mode-card" data-mode="multi">
                <div class="mode-icon">üë•</div>
                <div class="mode-name">MULTIPLAYER</div>
                <div class="mode-desc">Play with friend online</div>
            </div>
        </div>
        
        <button class="menu-btn" id="mode-continue-btn" disabled>SELECT A MODE</button>
    </div>
    
    <!-- MULTIPLAYER LOBBY -->
    <div id="multiplayer-lobby" class="menu-screen hidden">
        <h1 class="menu-title">MULTIPLAYER LOBBY</h1>
        
        <div id="lobby-host" style="display: none;">
            <div class="room-code-display">
                <h3>Your Room Code:</h3>
                <div class="room-code" id="room-code-display">----</div>
            </div>
            <p class="waiting-message">Waiting for opponent to join...</p>
        </div>
        
        <div id="lobby-join">
            <p class="menu-subtitle">Enter Room Code:</p>
            <input type="text" class="room-input" id="room-code-input" placeholder="Enter code" maxlength="4">
            <br>
            <button class="menu-btn" id="join-room-btn">JOIN ROOM</button>
            <br>
            <p style="margin: 20px 0; color: #888;">- OR -</p>
            <button class="menu-btn" id="create-room-btn">CREATE ROOM</button>
        </div>
        
        <button class="menu-btn" id="back-to-mode-btn" style="margin-top: 30px; background: rgba(255,255,255,0.1);">‚Üê BACK</button>
    </div>

    <!-- TEAM SELECTION SCREEN -->
    <div id="team-selection" class="menu-screen hidden">
        <h1 class="menu-title">‚öΩ CHOOSE YOUR TEAM ‚öΩ</h1>
        <p class="menu-subtitle">Select Your Player & Team</p>
        
        <div class="team-selection">
            <div class="team-card pirates" data-team="pirates" data-player="kele">
                <div class="team-logo">‚ò†Ô∏è</div>
                <div class="team-name">PIRATES</div>
                <div class="team-player">Kele</div>
                <div class="team-stats">
                    <div class="stat">
                        <div class="stat-value">85</div>
                        <div class="stat-label">Speed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">90</div>
                        <div class="stat-label">Shooting</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">80</div>
                        <div class="stat-label">Control</div>
                    </div>
                </div>
            </div>
            
            <div class="team-card sundowns" data-team="sundowns" data-player="lele">
                <div class="team-logo">‚òÄÔ∏è</div>
                <div class="team-name">SUNDOWNS</div>
                <div class="team-player">Lele</div>
                <div class="team-stats">
                    <div class="stat">
                        <div class="stat-value">88</div>
                        <div class="stat-label">Speed</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">85</div>
                        <div class="stat-label">Shooting</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value">92</div>
                        <div class="stat-label">Control</div>
                    </div>
                </div>
            </div>
        </div>
        
        <button class="menu-btn" id="start-btn" disabled>SELECT A TEAM</button>
    </div>
    
    <!-- INSTRUCTIONS SCREEN -->
    <div id="instructions-screen" class="menu-screen hidden">
        <div class="instructions-content">
            <h1 class="menu-title">HOW TO PLAY</h1>
            
            <div class="instruction-section">
                <h3>üéÆ Desktop Controls</h3>
                <div class="instruction-item">
                    <div class="instruction-key">W A S D</div>
                    <div class="instruction-desc">Move your player around the pitch</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-key">SPACE</div>
                    <div class="instruction-desc">Hold to charge power, release to shoot/pass</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-key">MOUSE</div>
                    <div class="instruction-desc">Drag to rotate camera view</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-key">C</div>
                    <div class="instruction-desc">Cycle through camera angles</div>
                </div>
            </div>
            
            <div class="instruction-section">
                <h3>üì± Mobile Controls</h3>
                <div class="instruction-item">
                    <div class="instruction-key">JOYSTICK</div>
                    <div class="instruction-desc">Drag the left joystick to move</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-key">SHOOT</div>
                    <div class="instruction-desc">Hold the red button to charge, release to shoot</div>
                </div>
            </div>
            
            <div class="instruction-section">
                <h3>‚öΩ Game Rules</h3>
                <div class="instruction-item">
                    <div class="instruction-desc">‚Ä¢ Score more goals than your opponent in 90 seconds</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-desc">‚Ä¢ Watch your stamina bar - it drains when moving and shooting</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-desc">‚Ä¢ Hold shoot button longer for more powerful shots</div>
                </div>
                <div class="instruction-item">
                    <div class="instruction-desc">‚Ä¢ Get close to the ball to control and kick it</div>
                </div>
            </div>
            
            <button class="menu-btn" id="play-btn">LET'S PLAY! ‚öΩ</button>
        </div>
    </div>
    
    <!-- GAME CONTAINER -->
    <div id="game-container"></div>
    
    <!-- GAME UI -->
    <div id="ui" style="display: none;">
        <div id="score">
            <span class="score-team score-pirates">Pirates 0</span>
            :
            <span class="score-team score-sundowns">Sundowns 0</span>
        </div>
        <div id="time">‚è±Ô∏è 1:30</div>
    </div>
    
    <button class="pause-btn" style="display: none;" id="pause-btn">‚è∏Ô∏è PAUSE</button>
    <button id="camera-btn" style="display: none;">üì∑ CAMERA</button>
    
    <div id="goal-alert">GOAL!</div>
    <div id="power-bar"><div id="power-fill"></div></div>
    
    <div id="stamina-bar" style="display: none;">
        <div class="stamina-label">STAMINA</div>
        <div class="stamina-bg">
            <div class="stamina-fill"></div>
        </div>
    </div>
    
    <div id="controls" style="display: none;">
        <div class="control-group">
            <div class="joystick-area" id="joystick-area">
                <div class="joystick" id="joystick"></div>
            </div>
        </div>
        
        <div class="control-group">
            <div class="action-btn" id="shoot-btn">SHOOT</div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // MULTIPLAYER STATE
        let gameMode = null;
        let isMultiplayer = false;
        let roomCode = null;
        let isHost = false;
        
        // Simple P2P using localStorage for demo
        const MultiplayerManager = {
            createRoom() {
                roomCode = Math.random().toString(36).substring(2, 6).toUpperCase();
                isHost = true;
                localStorage.setItem(`room_${roomCode}`, JSON.stringify({
                    host: true,
                    hostTeam: null,
                    guestTeam: null,
                    hostReady: false,
                    guestReady: false,
                    gameState: null
                }));
                return roomCode;
            },
            
            joinRoom(code) {
                const room = localStorage.getItem(`room_${code}`);
                if (room) {
                    roomCode = code;
                    isHost = false;
                    return true;
                }
                return false;
            },
            
            updateRoom(data) {
                if (!roomCode) return;
                const room = JSON.parse(localStorage.getItem(`room_${roomCode}`) || '{}');
                Object.assign(room, data);
                localStorage.setItem(`room_${roomCode}`, JSON.stringify(room));
            },
            
            getRoom() {
                if (!roomCode) return null;
                return JSON.parse(localStorage.getItem(`room_${roomCode}`) || 'null');
            },
            
            watchRoom(callback) {
                if (!roomCode) return;
                setInterval(() => {
                    const room = this.getRoom();
                    if (room) callback(room);
                }, 100);
            }
        };
        
        // GAME STATE
        let selectedTeam = null;
        let selectedPlayer = null;
        
        const gameState = {
            score: { pirates: 0, sundowns: 0 },
            time: 90,
            isPlaying: false,
            powerShot: 0,
            isCharging: false,
            playerStamina: 100,
            aiStamina: 100,
            cameraMode: 0 // 0: follow, 1: stadium, 2: goal, 3: side
        };
        
        // MODE SELECTION
        document.querySelectorAll('.mode-card').forEach(card => {
            card.addEventListener('click', function() {
                document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');
                
                gameMode = this.dataset.mode;
                isMultiplayer = gameMode === 'multi';
                
                document.getElementById('mode-continue-btn').disabled = false;
                document.getElementById('mode-continue-btn').textContent = 'CONTINUE';
            });
        });
        
        document.getElementById('mode-continue-btn').addEventListener('click', () => {
            if (gameMode === 'single') {
                document.getElementById('mode-selection').classList.add('hidden');
                document.getElementById('team-selection').classList.remove('hidden');
            } else if (gameMode === 'multi') {
                document.getElementById('mode-selection').classList.add('hidden');
                document.getElementById('multiplayer-lobby').classList.remove('hidden');
            }
        });
        
        // MULTIPLAYER LOBBY
        document.getElementById('create-room-btn').addEventListener('click', () => {
            const code = MultiplayerManager.createRoom();
            document.getElementById('room-code-display').textContent = code;
            document.getElementById('lobby-join').style.display = 'none';
            document.getElementById('lobby-host').style.display = 'block';
            
            MultiplayerManager.watchRoom((room) => {
                if (room.guestTeam && room.hostTeam) {
                    document.getElementById('lobby-host').innerHTML = '<p class="menu-subtitle">Opponent joined! Ready to start...</p>';
                    setTimeout(() => {
                        document.getElementById('multiplayer-lobby').classList.add('hidden');
                        document.getElementById('team-selection').classList.remove('hidden');
                    }, 1000);
                }
            });
        });
        
        document.getElementById('join-room-btn').addEventListener('click', () => {
            const code = document.getElementById('room-code-input').value.toUpperCase();
            if (MultiplayerManager.joinRoom(code)) {
                roomCode = code;
                document.getElementById('multiplayer-lobby').innerHTML = `
                    <h1 class="menu-title">JOINED ROOM</h1>
                    <p class="menu-subtitle">Waiting for host to start...</p>
                    <div class="room-code-display">
                        <h3>Room Code:</h3>
                        <div class="room-code">${code}</div>
                    </div>
                `;
                
                MultiplayerManager.watchRoom((room) => {
                    if (room.gameState === 'starting') {
                        document.getElementById('multiplayer-lobby').classList.add('hidden');
                        document.getElementById('team-selection').classList.remove('hidden');
                    }
                });
            } else {
                alert('Invalid room code!');
            }
        });
        
        document.getElementById('back-to-mode-btn').addEventListener('click', () => {
            document.getElementById('multiplayer-lobby').classList.add('hidden');
            document.getElementById('mode-selection').classList.remove('hidden');
        });
        
        // TEAM SELECTION
        document.querySelectorAll('.team-card').forEach(card => {
            card.addEventListener('click', function() {
                document.querySelectorAll('.team-card').forEach(c => c.classList.remove('selected'));
                this.classList.add('selected');
                
                selectedTeam = this.dataset.team;
                selectedPlayer = this.dataset.player;
                
                document.getElementById('start-btn').disabled = false;
                document.getElementById('start-btn').textContent = 'CONTINUE';
                
                if (isMultiplayer && roomCode) {
                    MultiplayerManager.updateRoom({
                        [isHost ? 'hostTeam' : 'guestTeam']: selectedTeam
                    });
                }
            });
        });
        
        document.getElementById('start-btn').addEventListener('click', () => {
            if (isMultiplayer) {
                if (isHost) {
                    MultiplayerManager.updateRoom({ gameState: 'starting' });
                }
            }
            document.getElementById('team-selection').classList.add('hidden');
            document.getElementById('instructions-screen').classList.remove('hidden');
        });
        
        document.getElementById('play-btn').addEventListener('click', () => {
            document.getElementById('instructions-screen').classList.add('hidden');
            startGame();
        });
        
        // GAME INITIALIZATION
        let scene, camera, renderer, controls;
        let field, ball, player, aiPlayer, goals = [];
        let playerModel, aiModel, ballModel;
        let fieldSize = { width: 80, height: 40 };
        let keys = {};
        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        let joystickActive = false;
        let joystickVector = new THREE.Vector2();
        let clock = new THREE.Clock();
        let playerAnimation = { time: 0, speed: 0 };
        let aiAnimation = { time: 0, speed: 0 };
        let ballTrail = [];
        let stadiumLights = [];
        let cameraTarget = new THREE.Vector3();
        let cameraOffset = new THREE.Vector3(0, 20, 30);
        let cameraSmoothness = 0.05;
        
        // Enhanced materials with realistic properties
        const materials = {
            grass: new THREE.MeshStandardMaterial({ 
                color: 0x2e7d32,
                roughness: 0.9,
                metalness: 0.1
            }),
            line: new THREE.LineBasicMaterial({ color: 0xffffff }),
            goal: new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x333333,
                emissiveIntensity: 0.1
            }),
            ball: new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                metalness: 0.9,
                roughness: 0.1,
                clearcoat: 1,
                clearcoatRoughness: 0
            }),
            playerPirates: new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                metalness: 0.3,
                roughness: 0.7
            }),
            playerSundowns: new THREE.MeshStandardMaterial({ 
                color: 0xFFD700,
                metalness: 0.5,
                roughness: 0.5,
                emissive: 0x333300,
                emissiveIntensity: 0.2
            }),
            stadium: new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.8,
                metalness: 0.2
            })
        };
        
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            scene.fog = new THREE.Fog(0x0a0a0a, 50, 200);
            
            // Enhanced renderer with better settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // Camera with multiple angles
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 40);
            
            if (!isMobile) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 10;
                controls.maxDistance = 80;
                controls.maxPolarAngle = Math.PI / 2.2;
                controls.enablePan = false;
            }
            
            // Advanced lighting system
            setupLighting();
            
            // Create realistic stadium
            createStadium();
            
            // Create detailed field
            createField();
            
            // Create goals with nets
            createGoals();
            
            // Create realistic ball
            createBall();
            
            // Create animated players
            createPlayers();
            
            // Setup controls
            setupControls();
            
            // Start game loop
            animate();
        }
        
        function setupLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xfff4e6, 1.2);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);
            
            // Stadium lights
            const lightPositions = [
                [-35, 25, -20], [35, 25, -20],
                [-35, 25, 20], [35, 25, 20],
                [0, 30, -25], [0, 30, 25]
            ];
            
            lightPositions.forEach(pos => {
                const spotLight = new THREE.SpotLight(0xffffff, 2, 100, Math.PI/6, 0.5, 2);
                spotLight.position.set(pos[0], pos[1], pos[2]);
                spotLight.castShadow = true;
                spotLight.shadow.mapSize.width = 1024;
                spotLight.shadow.mapSize.height = 1024;
                scene.add(spotLight);
                stadiumLights.push(spotLight);
                
                // Light helper (visible part)
                const lightGeometry = new THREE.SphereGeometry(1, 16, 16);
                const lightMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 2
                });
                const lightSphere = new THREE.Mesh(lightGeometry, lightMaterial);
                lightSphere.position.set(pos[0], pos[1], pos[2]);
                scene.add(lightSphere);
            });
            
            // Rim light for dramatic effect
            const rimLight = new THREE.DirectionalLight(0x4466ff, 0.3);
            rimLight.position.set(-50, 20, 0);
            scene.add(rimLight);
        }
        
        function createStadium() {
            // Stadium base
            const stadiumGeometry = new THREE.RingGeometry(45, 60, 64);
            const stadiumMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                side: THREE.DoubleSide
            });
            const stadiumBase = new THREE.Mesh(stadiumGeometry, stadiumMaterial);
            stadiumBase.rotation.x = -Math.PI / 2;
            stadiumBase.position.y = -0.1;
            scene.add(stadiumBase);
            
            // Stadium walls with texture-like appearance
            const wallHeight = 8;
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.8,
                metalness: 0.2
            });
            
            // Create walls with slight variations
            const createWall = (width, height, position, rotation) => {
                const wall = new THREE.Mesh(
                    new THREE.PlaneGeometry(width, height),
                    wallMaterial
                );
                wall.position.set(position.x, position.y, position.z);
                wall.rotation.set(rotation.x, rotation.y, rotation.z);
                return wall;
            };
            
            scene.add(createWall(120, wallHeight, 
                new THREE.Vector3(0, wallHeight/2, -fieldSize.height/2 - 10), 
                new THREE.Vector3(0, Math.PI, 0)));
            scene.add(createWall(120, wallHeight, 
                new THREE.Vector3(0, wallHeight/2, fieldSize.height/2 + 10), 
                new THREE.Vector3(0, 0, 0)));
            scene.add(createWall(80, wallHeight, 
                new THREE.Vector3(fieldSize.width/2 + 10, wallHeight/2, 0), 
                new THREE.Vector3(0, Math.PI / 2, 0)));
            scene.add(createWall(80, wallHeight, 
                new THREE.Vector3(-fieldSize.width/2 - 10, wallHeight/2, 0), 
                new THREE.Vector3(0, -Math.PI / 2, 0)));
            
            // Stadium light poles
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 30, 16);
            const poleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                metalness: 0.8,
                roughness: 0.2
            });
            
            [[-45, 15, -25], [45, 15, -25], [-45, 15, 25], [45, 15, 25]].forEach(pos => {
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(pos[0], pos[1], pos[2]);
                scene.add(pole);
            });
        }
        
        function createField() {
            // Grass with texture-like pattern using vertex colors
            const grassGeometry = new THREE.PlaneGeometry(fieldSize.width, fieldSize.height, 50, 50);
            
            // Create grass color variation for realism
            const positions = grassGeometry.attributes.position;
            const colors = [];
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i);
                const baseColor = new THREE.Color(0x2e7d32);
                // Add slight color variation
                const variation = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 0.1;
                baseColor.offsetHSL(0, 0, variation);
                colors.push(baseColor.r, baseColor.g, baseColor.b);
            }
            grassGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            materials.grass.vertexColors = true;
            
            field = new THREE.Mesh(grassGeometry, materials.grass);
            field.rotation.x = -Math.PI / 2;
            field.receiveShadow = true;
            scene.add(field);
            
            // Field markings with realistic dimensions
            const lineWidth = 0.3;
            
            // Center circle
            const centerCircle = new THREE.RingGeometry(9.15 - lineWidth/2, 9.15 + lineWidth/2, 64);
            const centerCircleMesh = new THREE.Mesh(centerCircle, materials.line);
            centerCircleMesh.rotation.x = Math.PI / 2;
            centerCircleMesh.position.y = 0.02;
            scene.add(centerCircleMesh);
            
            // Center point
            const centerPoint = new THREE.Mesh(
                new THREE.CircleGeometry(0.3, 16),
                materials.line
            );
            centerPoint.rotation.x = -Math.PI / 2;
            centerPoint.position.y = 0.02;
            scene.add(centerPoint);
            
            // Center line
            const centerLine = new THREE.Mesh(
                new THREE.PlaneGeometry(lineWidth, fieldSize.height),
                materials.line
            );
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.y = 0.02;
            scene.add(centerLine);
            
            // Penalty areas
            createPenaltyAreas();
            
            // Corner arcs
            createCornerArcs();
        }
        
        function createPenaltyAreas() {
            const lineWidth = 0.3;
            const penaltyAreaDepth = 16.5;
            const penaltyAreaWidth = 40.3;
            const goalAreaDepth = 5.5;
            const goalAreaWidth = 18.32;
            
            // Left penalty area
            const leftPenaltyGroup = new THREE.Group();
            
            // Outer rectangle
            const leftOuter = new THREE.Mesh(
                new THREE.PlaneGeometry(penaltyAreaWidth, penaltyAreaDepth),
                materials.line
            );
            leftOuter.rotation.x = -Math.PI / 2;
            leftOuter.position.set(0, 0.02, -fieldSize.height/2 + penaltyAreaDepth/2);
            leftPenaltyGroup.add(leftOuter);
            
            // Goal area inside
            const leftGoalArea = new THREE.Mesh(
                new THREE.PlaneGeometry(goalAreaWidth, goalAreaDepth),
                materials.line
            );
            leftGoalArea.rotation.x = -Math.PI / 2;
            leftGoalArea.position.set(0, 0.03, -fieldSize.height/2 + goalAreaDepth/2);
            leftPenaltyGroup.add(leftGoalArea);
            
            scene.add(leftPenaltyGroup);
            
            // Right penalty area (mirrored)
            const rightPenaltyGroup = new THREE.Group();
            
            const rightOuter = leftOuter.clone();
            rightOuter.position.z = fieldSize.height/2 - penaltyAreaDepth/2;
            rightPenaltyGroup.add(rightOuter);
            
            const rightGoalArea = leftGoalArea.clone();
            rightGoalArea.position.z = fieldSize.height/2 - goalAreaDepth/2;
            rightPenaltyGroup.add(rightGoalArea);
            
            scene.add(rightPenaltyGroup);
        }
        
        function createCornerArcs() {
            const cornerRadius = 1;
            const arcGeometry = new THREE.RingGeometry(cornerRadius - 0.15, cornerRadius + 0.15, 16, 1, 0, Math.PI/2);
            const arcMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
            
            // Four corners
            const corners = [
                { x: -fieldSize.width/2, z: -fieldSize.height/2, rotation: 0 },
                { x: fieldSize.width/2, z: -fieldSize.height/2, rotation: Math.PI/2 },
                { x: -fieldSize.width/2, z: fieldSize.height/2, rotation: -Math.PI/2 },
                { x: fieldSize.width/2, z: fieldSize.height/2, rotation: Math.PI }
            ];
            
            corners.forEach(corner => {
                const arc = new THREE.Mesh(arcGeometry, arcMaterial);
                arc.rotation.x = Math.PI / 2;
                arc.rotation.y = corner.rotation;
                arc.position.set(corner.x, 0.02, corner.z);
                scene.add(arc);
            });
        }
        
        function createGoals() {
            const goalPostGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2.44, 8);
            const goalCrossbarGeometry = new THREE.CylinderGeometry(0.1, 0.1, 7.32, 8);
            
            // Left goal (Pirates)
            const leftGoal = new THREE.Group();
            
            // Left post
            const leftPost1 = new THREE.Mesh(goalPostGeometry, materials.goal);
            leftPost1.position.set(-3.66, 1.22, -fieldSize.height/2);
            leftGoal.add(leftPost1);
            
            // Right post
            const leftPost2 = new THREE.Mesh(goalPostGeometry, materials.goal);
            leftPost2.position.set(3.66, 1.22, -fieldSize.height/2);
            leftGoal.add(leftPost2);
            
            // Crossbar
            const leftCrossbar = new THREE.Mesh(goalCrossbarGeometry, materials.goal);
            leftCrossbar.rotation.z = Math.PI / 2;
            leftCrossbar.position.set(0, 2.44, -fieldSize.height/2);
            leftGoal.add(leftCrossbar);
            
            // Net
            const leftNet = createGoalNet(-fieldSize.height/2);
            leftGoal.add(leftNet);
            
            scene.add(leftGoal);
            goals.push({ mesh: leftGoal, team: 'sundowns' });
            
            // Right goal (Sundowns)
            const rightGoal = new THREE.Group();
            
            // Left post
            const rightPost1 = new THREE.Mesh(goalPostGeometry, materials.goal);
            rightPost1.position.set(-3.66, 1.22, fieldSize.height/2);
            rightGoal.add(rightPost1);
            
            // Right post
            const rightPost2 = new THREE.Mesh(goalPostGeometry, materials.goal);
            rightPost2.position.set(3.66, 1.22, fieldSize.height/2);
            rightGoal.add(rightPost2);
            
            // Crossbar
            const rightCrossbar = new THREE.Mesh(goalCrossbarGeometry, materials.goal);
            rightCrossbar.rotation.z = Math.PI / 2;
            rightCrossbar.position.set(0, 2.44, fieldSize.height/2);
            rightGoal.add(rightCrossbar);
            
            // Net
            const rightNet = createGoalNet(fieldSize.height/2);
            rightGoal.add(rightNet);
            
            scene.add(rightGoal);
            goals.push({ mesh: rightGoal, team: 'pirates' });
        }
        
        function createGoalNet(zPos) {
            const netGeometry = new THREE.BoxGeometry(7.52, 2.54, 1.5);
            const netMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(0, 1.27, zPos + (zPos > 0 ? -0.75 : 0.75));
            return net;
        }
        
        function createBall() {
            // Realistic soccer ball with hexagon pattern
            const ballGeometry = new THREE.SphereGeometry(0.22, 32, 32);
            
            // Create canvas texture for ball pattern
            const textureCanvas = document.createElement('canvas');
            textureCanvas.width = 512;
            textureCanvas.height = 512;
            const ctx = textureCanvas.getContext('2d');
            
            // Draw black hexagons on white background
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            
            ctx.fillStyle = '#000000';
            const hexSize = 40;
            for (let y = 0; y < 512; y += hexSize * 1.5) {
                for (let x = 0; x < 512; x += hexSize * Math.sqrt(3)) {
                    if ((y / (hexSize * 1.5)) % 2 === 0) {
                        drawHexagon(ctx, x, y, hexSize);
                    } else {
                        drawHexagon(ctx, x + hexSize * Math.sqrt(3) / 2, y, hexSize);
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(textureCanvas);
            materials.ball.map = texture;
            
            ballModel = new THREE.Mesh(ballGeometry, materials.ball);
            ballModel.castShadow = true;
            ballModel.receiveShadow = true;
            ballModel.position.set(0, 0.22, 0);
            scene.add(ballModel);
            
            // Initialize ball physics
            ball = {
                mesh: ballModel,
                velocity: new THREE.Vector3(0, 0, 0),
                angularVelocity: new THREE.Vector3(0, 0, 0),
                position: new THREE.Vector3(0, 0.22, 0),
                friction: 0.99,
                airResistance: 0.999,
                gravity: -0.02,
                spin: 0,
                lastPosition: new THREE.Vector3(0, 0.22, 0),
                trail: []
            };
            
            // Create ball trail particles
            for (let i = 0; i < 8; i++) {
                const trailGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const trailMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                scene.add(trail);
                ball.trail.push({ mesh: trail, life: 0 });
            }
        }
        
        function drawHexagon(ctx, x, y, size) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const px = x + size * Math.cos(angle);
                const py = y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
        }
        
        function createPlayers() {
            // Create humanoid player models with realistic proportions
            const createPlayerModel = (teamColor, isPlayer = true) => {
                const group = new THREE.Group();
                
                // Body (torso)
                const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 8, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: teamColor,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 1.6;
                body.castShadow = true;
                group.add(body);
                
                // Head
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFE0BD,
                    roughness: 0.8
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2.5;
                head.castShadow = true;
                group.add(head);
                
                // Arms
                const armGeometry = new THREE.CapsuleGeometry(0.12, 0.6, 8, 8);
                const armMaterial = new THREE.MeshStandardMaterial({ 
                    color: teamColor,
                    roughness: 0.7
                });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.6, 1.8, 0);
                leftArm.rotation.z = Math.PI / 4;
                group.add(leftArm);
                
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.6, 1.8, 0);
                rightArm.rotation.z = -Math.PI / 4;
                group.add(rightArm);
                
                // Legs
                const legGeometry = new THREE.CapsuleGeometry(0.15, 1.0, 8, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    roughness: 0.8
                });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.25, 0.6, 0);
                group.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.25, 0.6, 0);
                group.add(rightLeg);
                
                // Feet
                const footGeometry = new THREE.BoxGeometry(0.3, 0.15, 0.5);
                const footMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x111111,
                    roughness: 0.5
                });
                
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.25, 0, 0.2);
                group.add(leftFoot);
                
                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.25, 0, 0.2);
                group.add(rightFoot);
                
                return group;
            };
            
            // Player model
            const playerColor = selectedTeam === 'pirates' ? 0x000000 : 0xFFD700;
            playerModel = createPlayerModel(playerColor, true);
            playerModel.position.set(-10, 0, 0);
            playerModel.castShadow = true;
            scene.add(playerModel);
            
            player = {
                mesh: playerModel,
                velocity: new THREE.Vector3(0, 0, 0),
                speed: selectedTeam === 'pirates' ? 0.25 : 0.23,
                acceleration: 0.5,
                deceleration: 0.9,
                stamina: 100,
                hasBall: false,
                team: selectedTeam,
                shootPower: 0,
                animationTime: 0,
                legOffset: 0,
                targetRotation: 0
            };
            
            // AI model
            const aiColor = selectedTeam === 'pirates' ? 0xFFD700 : 0x000000;
            aiModel = createPlayerModel(aiColor, false);
            aiModel.position.set(10, 0, 0);
            aiModel.castShadow = true;
            scene.add(aiModel);
            
            aiPlayer = {
                mesh: aiModel,
                velocity: new THREE.Vector3(0, 0, 0),
                speed: selectedTeam === 'pirates' ? 0.22 : 0.20,
                acceleration: 0.4,
                deceleration: 0.9,
                stamina: 100,
                hasBall: false,
                team: selectedTeam === 'pirates' ? 'sundowns' : 'pirates',
                target: new THREE.Vector3(0, 0, 0),
                animationTime: 0,
                legOffset: Math.PI
            };
        }
        
        function setupControls() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                if (e.key === ' ' && !gameState.isCharging && gameState.isPlaying) {
                    startCharging();
                }
                if (e.key === 'c' && gameState.isPlaying) {
                    cycleCamera();
                }
            });
            
            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                if (e.key === ' ' && gameState.isCharging) {
                    shoot();
                }
            });
            
            // Mobile controls
            if (isMobile) {
                const joystick = document.getElementById('joystick');
                const joystickArea = document.getElementById('joystick-area');
                const shootBtn = document.getElementById('shoot-btn');
                
                let joystickStart = null;
                
                joystickArea.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    joystickStart = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                    joystickActive = true;
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!joystickStart || !joystickActive) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - joystickStart.x;
                    const deltaY = touch.clientY - joystickStart.y;
                    
                    const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), 50);
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    joystickVector.set(
                        Math.cos(angle) * (distance / 50),
                        Math.sin(angle) * (distance / 50)
                    );
                    
                    // Move joystick visual
                    joystick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                });
                
                document.addEventListener('touchend', (e) => {
                    joystickActive = false;
                    joystickVector.set(0, 0);
                    joystick.style.transform = 'translate(-50%, -50%)';
                    joystickStart = null;
                });
                
                shootBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameState.isPlaying && !gameState.isCharging) {
                        startCharging();
                    }
                });
                
                shootBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (gameState.isCharging) {
                        shoot();
                    }
                });
            }
            
            // Pause button
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            
            // Camera button
            document.getElementById('camera-btn').addEventListener('click', cycleCamera);
        }
        
        function cycleCamera() {
            gameState.cameraMode = (gameState.cameraMode + 1) % 4;
            
            // Update camera positions based on mode
            switch(gameState.cameraMode) {
                case 0: // Follow player
                    cameraOffset.set(0, 15, 25);
                    break;
                case 1: // Stadium view
                    cameraOffset.set(0, 40, 0);
                    break;
                case 2: // Goal view
                    cameraOffset.set(0, 10, 45);
                    break;
                case 3: // Side view
                    cameraOffset.set(40, 15, 0);
                    break;
            }
        }
        
        function startCharging() {
            if (!player.hasBall || gameState.playerStamina < 10) return;
            
            gameState.isCharging = true;
            document.getElementById('power-bar').style.display = 'block';
            
            const chargeInterval = setInterval(() => {
                if (gameState.isCharging) {
                    gameState.powerShot = Math.min(gameState.powerShot + 2, 100);
                    document.getElementById('power-fill').style.width = gameState.powerShot + '%';
                    
                    // Drain stamina while charging
                    gameState.playerStamina = Math.max(0, gameState.playerStamina - 0.5);
                    updateStaminaBar();
                    
                    if (gameState.powerShot >= 100) {
                        clearInterval(chargeInterval);
                        shoot();
                    }
                } else {
                    clearInterval(chargeInterval);
                }
            }, 50);
        }
        
        function shoot() {
            if (!gameState.isCharging || !player.hasBall) return;
            
            gameState.isCharging = false;
            document.getElementById('power-bar').style.display = 'none';
            
            // Calculate shoot direction with realistic physics
            const shootPower = gameState.powerShot / 15; // Adjusted for realistic power
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0.2 + (gameState.powerShot / 200); // Higher power = higher shot
            direction.normalize();
            
            // Add spin based on shot power
            ball.angularVelocity.set(
                (Math.random() - 0.5) * shootPower * 0.1,
                (Math.random() - 0.5) * shootPower * 0.1,
                (Math.random() - 0.5) * shootPower * 0.1
            );
            
            ball.velocity.copy(direction.multiplyScalar(shootPower));
            player.hasBall = false;
            
            // Add shooting animation
            player.animationTime = 0;
            
            // Drain stamina for shooting
            gameState.playerStamina = Math.max(0, gameState.playerStamina - (gameState.powerShot / 5));
            updateStaminaBar();
            
            gameState.powerShot = 0;
        }
        
        function updateStaminaBar() {
            document.querySelector('.stamina-fill').style.width = gameState.playerStamina + '%';
        }
        
        function togglePause() {
            gameState.isPlaying = !gameState.isPlaying;
            document.getElementById('pause-btn').textContent = gameState.isPlaying ? '‚è∏Ô∏è PAUSE' : '‚ñ∂Ô∏è RESUME';
        }
        
        function startGame() {
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('stamina-bar').style.display = 'block';
            document.getElementById('pause-btn').style.display = 'block';
            document.getElementById('camera-btn').style.display = 'block';
            
            if (isMobile) {
                document.getElementById('controls').style.display = 'flex';
            }
            
            gameState.isPlaying = true;
            init();
            startGameTimer();
        }
        
        function startGameTimer() {
            const timerInterval = setInterval(() => {
                if (gameState.isPlaying) {
                    gameState.time--;
                    
                    const minutes = Math.floor(gameState.time / 60);
                    const seconds = gameState.time % 60;
                    document.getElementById('time').textContent = 
                        `‚è±Ô∏è ${minutes}:${seconds.toString().padStart(2, '0')}`;
                    
                    if (gameState.time <= 0) {
                        clearInterval(timerInterval);
                        endGame();
                    }
                }
            }, 1000);
        }
        
        function updateAI() {
            if (!gameState.isPlaying) return;
            
            const ballPos = ball.position;
            const aiPos = aiPlayer.mesh.position;
            const deltaTime = clock.getDelta();
            
            // Calculate distance to ball
            const distanceToBall = aiPos.distanceTo(ballPos);
            
            if (aiPlayer.hasBall) {
                // AI has ball - move towards opponent's goal
                const targetGoal = goals.find(g => g.team === player.team).mesh.position;
                const direction = new THREE.Vector3().subVectors(targetGoal, aiPos);
                direction.y = 0;
                direction.normalize();
                
                // Smooth acceleration
                aiPlayer.velocity.lerp(direction.multiplyScalar(aiPlayer.speed), aiPlayer.acceleration * deltaTime);
                
                // Update animation
                aiPlayer.animationTime += deltaTime * 5;
                aiPlayer.legOffset = Math.sin(aiPlayer.animationTime) * 0.3;
                
                // Randomly shoot when in good position
                if (distanceToBall < 15 && Math.random() < 0.01 && gameState.aiStamina > 20) {
                    const shootDir = new THREE.Vector3().subVectors(targetGoal, aiPos).normalize();
                    shootDir.y = 0.15 + Math.random() * 0.1;
                    ball.velocity.copy(shootDir.multiplyScalar(1.2 + Math.random() * 0.3));
                    ball.angularVelocity.set(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1
                    );
                    aiPlayer.hasBall = false;
                    gameState.aiStamina = Math.max(0, gameState.aiStamina - 20);
                }
            } else {
                // AI doesn't have ball - chase ball or intercept
                const direction = new THREE.Vector3().subVectors(ballPos, aiPos);
                direction.y = 0;
                
                if (distanceToBall > 1.0) {
                    direction.normalize();
                    aiPlayer.velocity.lerp(direction.multiplyScalar(aiPlayer.speed), aiPlayer.acceleration * deltaTime);
                    
                    // Update animation
                    aiPlayer.animationTime += deltaTime * 5;
                    aiPlayer.legOffset = Math.sin(aiPlayer.animationTime) * 0.3;
                    
                    // Try to steal ball from player
                    if (distanceToBall < 2.0 && player.hasBall && Math.random() < 0.02) {
                        player.hasBall = false;
                        aiPlayer.hasBall = true;
                        ball.velocity.set(0, 0, 0);
                    }
                } else {
                    aiPlayer.velocity.lerp(new THREE.Vector3(0, 0, 0), aiPlayer.deceleration);
                    aiPlayer.legOffset = 0;
                    aiPlayer.hasBall = true;
                    ball.position.copy(aiPos.clone().add(new THREE.Vector3(0, 0, 1.5)));
                    ball.velocity.set(0, 0, 0);
                }
            }
            
            // Update AI stamina
            if (aiPlayer.velocity.length() > 0.01) {
                gameState.aiStamina = Math.max(0, gameState.aiStamina - 0.15 * deltaTime * 60);
            } else {
                gameState.aiStamina = Math.min(100, gameState.aiStamina + 0.3 * deltaTime * 60);
            }
            
            // Apply velocity
            aiPos.add(aiPlayer.velocity);
            
            // Rotate AI to face movement direction
            if (aiPlayer.velocity.length() > 0.01) {
                const targetAngle = Math.atan2(aiPlayer.velocity.x, aiPlayer.velocity.z);
                aiPlayer.mesh.rotation.y = targetAngle;
            }
            
            // Boundary check
            aiPos.x = Math.max(-fieldSize.width/2 + 2, Math.min(fieldSize.width/2 - 2, aiPos.x));
            aiPos.z = Math.max(-fieldSize.height/2 + 2, Math.min(fieldSize.height/2 - 2, aiPos.z));
            
            // Animate AI legs
            animatePlayerLegs(aiModel, aiPlayer.legOffset);
        }
        
        function updatePlayer() {
            if (!gameState.isPlaying) return;
            
            const playerPos = player.mesh.position;
            const deltaTime = clock.getDelta();
            let moveVector = new THREE.Vector3();
            
            if (isMobile && joystickActive) {
                // Mobile joystick movement
                moveVector.set(joystickVector.x, 0, -joystickVector.y);
            } else {
                // Keyboard movement
                if (keys['w'] || keys['arrowup']) moveVector.z -= 1;
                if (keys['s'] || keys['arrowdown']) moveVector.z += 1;
                if (keys['a'] || keys['arrowleft']) moveVector.x -= 1;
                if (keys['d'] || keys['arrowright']) moveVector.x += 1;
            }
            
            if (moveVector.length() > 0) {
                moveVector.normalize();
                
                // Smooth acceleration
                player.velocity.lerp(moveVector.multiplyScalar(player.speed), player.acceleration * deltaTime);
                
                // Update animation
                player.animationTime += deltaTime * 6;
                player.legOffset = Math.sin(player.animationTime) * 0.3;
                
                // Drain stamina while moving
                gameState.playerStamina = Math.max(0, gameState.playerStamina - 0.2 * deltaTime * 60);
            } else {
                // Smooth deceleration
                player.velocity.lerp(new THREE.Vector3(0, 0, 0), player.deceleration);
                player.legOffset = 0;
                
                // Recover stamina when not moving
                gameState.playerStamina = Math.min(100, gameState.playerStamina + 0.5 * deltaTime * 60);
            }
            
            // Apply velocity with stamina effect
            const staminaMultiplier = gameState.playerStamina > 20 ? 1 : 0.5;
            playerPos.add(player.velocity.multiplyScalar(staminaMultiplier));
            
            // Rotate player to face movement direction
            if (player.velocity.length() > 0.01) {
                const targetAngle = Math.atan2(player.velocity.x, player.velocity.z);
                player.mesh.rotation.y = targetAngle;
            }
            
            // Boundary check
            playerPos.x = Math.max(-fieldSize.width/2 + 2, Math.min(fieldSize.width/2 - 2, playerPos.x));
            playerPos.z = Math.max(-fieldSize.height/2 + 2, Math.min(fieldSize.height/2 - 2, playerPos.z));
            
            // Check ball possession
            const distanceToBall = playerPos.distanceTo(ball.position);
            if (distanceToBall < 2.0 && !aiPlayer.hasBall) {
                player.hasBall = true;
                ball.velocity.set(0, 0, 0);
                
                // Position ball in front of player
                const ballOffset = new THREE.Vector3(0, 0, 1.5);
                ballOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), player.mesh.rotation.y);
                
                ball.position.copy(playerPos.clone().add(ballOffset));
                ball.position.y = 0.22;
            }
            
            // Animate player legs
            animatePlayerLegs(playerModel, player.legOffset);
            
            updateStaminaBar();
        }
        
        function animatePlayerLegs(model, offset) {
            // Animate legs for walking/running
            const legs = model.children.filter(child => 
                child.geometry && child.geometry.type === 'CapsuleGeometry' && 
                child.position.y < 1.5
            );
            
            if (legs.length >= 2) {
                legs[0].rotation.x = offset; // Left leg
                legs[1].rotation.x = -offset; // Right leg
            }
            
            // Animate arms (opposite to legs)
            const arms = model.children.filter(child => 
                child.geometry && child.geometry.type === 'CapsuleGeometry' && 
                child.position.y > 1.5
            );
            
            if (arms.length >= 2) {
                arms[0].rotation.x = -offset * 0.5; // Left arm
                arms[1].rotation.x = offset * 0.5; // Right arm
            }
        }
        
        function updateBall() {
            if (!gameState.isPlaying) return;
            
            const deltaTime = clock.getDelta();
            
            // Apply gravity
            ball.velocity.y += ball.gravity;
            
            // Apply air resistance
            ball.velocity.multiplyScalar(ball.airResistance);
            
            // Apply ground friction (only when on ground)
            if (ball.position.y <= 0.22) {
                const groundFriction = 0.98;
                ball.velocity.x *= groundFriction;
                ball.velocity.z *= groundFriction;
            }
            
            // Update position
            ball.position.add(ball.velocity);
            
            // Update rotation based on angular velocity
            ball.mesh.rotation.x += ball.angularVelocity.x * deltaTime * 20;
            ball.mesh.rotation.y += ball.angularVelocity.y * deltaTime * 20;
            ball.mesh.rotation.z += ball.angularVelocity.z * deltaTime * 20;
            
            // Bounce on ground with energy loss
            if (ball.position.y <= 0.22) {
                ball.position.y = 0.22;
                ball.velocity.y *= -0.7; // Bounce with energy loss
                ball.angularVelocity.multiplyScalar(0.9); // Reduce spin on bounce
                
                // Create bounce effect particles
                createBounceEffect(ball.position);
            }
            
            // Boundary collision with realistic bounce
            if (Math.abs(ball.position.x) > fieldSize.width/2 - 0.5) {
                ball.position.x = Math.sign(ball.position.x) * (fieldSize.width/2 - 0.5);
                ball.velocity.x *= -0.8;
                ball.angularVelocity.y *= -0.5;
            }
            
            if (Math.abs(ball.position.z) > fieldSize.height/2 - 0.5) {
                ball.position.z = Math.sign(ball.position.z) * (fieldSize.height/2 - 0.5);
                ball.velocity.z *= -0.8;
                ball.angularVelocity.x *= -0.5;
            }
            
            // Update ball trail
            updateBallTrail(deltaTime);
            
            // Update mesh position
            ball.mesh.position.copy(ball.position);
            
            // Check for goals
            checkGoals();
        }
        
        function updateBallTrail(deltaTime) {
            // Add new trail point
            ball.trail.unshift({
                position: ball.position.clone(),
                life: 1.0
            });
            
            // Keep only last 8 trail points
            if (ball.trail.length > 8) {
                ball.trail.pop();
            }
            
            // Update trail particles
            for (let i = 0; i < ball.trail.length; i++) {
                const trail = ball.trail[i];
                trail.life -= deltaTime * 2;
                
                if (trail.life > 0) {
                    // Update trail particle position and opacity
                    if (ball.trail[i + 1]) {
                        trail.position.lerp(ball.trail[i + 1].position, 0.1);
                    }
                    
                    // Create visual trail effect
                    if (i < ball.trail.length - 1 && ball.velocity.length() > 0.5) {
                        const trailGeometry = new THREE.SphereGeometry(0.05 * (1 - i/8), 4, 4);
                        const trailMaterial = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: trail.life * 0.3
                        });
                        
                        // Create temporary trail mesh
                        const trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
                        trailMesh.position.copy(trail.position);
                        scene.add(trailMesh);
                        
                        // Remove after one frame
                        setTimeout(() => scene.remove(trailMesh), 16);
                    }
                }
            }
        }
        
        function createBounceEffect(position) {
            // Create bounce particles
            for (let i = 0; i < 3; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.copy(position);
                particle.position.y = 0.3;
                
                // Random velocity for particles
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.5
                );
                
                scene.add(particle);
                
                // Animate and remove particle
                const animateParticle = () => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.y -= 0.02;
                    particle.material.opacity -= 0.03;
                    
                    if (particle.material.opacity > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                    }
                };
                
                animateParticle();
            }
        }
        
        function checkGoals() {
            const ballPos = ball.position;
            
            for (const goal of goals) {
                const goalPos = goal.mesh.position;
                
                // Check if ball is in goal area
                const inGoalWidth = Math.abs(ballPos.x - goalPos.x) < 3.8;
                const inGoalHeight = ballPos.y > 0 && ballPos.y < 2.5;
                const inGoalDepth = Math.abs(ballPos.z - goalPos.z) < 1.0;
                
                if (inGoalWidth && inGoalHeight && inGoalDepth) {
                    scoreGoal(goal.team);
                    resetBall();
                    return;
                }
            }
        }
        
        function scoreGoal(scoringTeam) {
            gameState.score[scoringTeam]++;
            
            // Update score display
            document.getElementById('score').innerHTML = `
                <span class="score-team score-pirates">Pirates ${gameState.score.pirates}</span>
                :
                <span class="score-team score-sundowns">Sundowns ${gameState.score.sundowns}</span>
            `;
            
            // Show goal alert with team colors
            const goalAlert = document.getElementById('goal-alert');
            goalAlert.textContent = 'GOAL!';
            goalAlert.style.transform = 'translate(-50%, -50%) scale(1)';
            goalAlert.style.backgroundColor = scoringTeam === 'pirates' ? 
                'rgba(0,0,0,0.9)' : 'rgba(255,215,0,0.2)';
            goalAlert.style.borderColor = scoringTeam === 'pirates' ? '#FFD700' : '#000000';
            
            // Create celebration particles
            createCelebrationParticles(scoringTeam);
            
            setTimeout(() => {
                goalAlert.style.transform = 'translate(-50%, -50%) scale(0)';
            }, 2000);
        }
        
        function createCelebrationParticles(team) {
            const particleColor = team === 'pirates' ? 0x000000 : 0xFFD700;
            
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: particleColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.set(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 10 + 5,
                    (Math.random() - 0.5) * 10
                );
                
                // Random velocity
                particle.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.5,
                    Math.random() * 0.5,
                    (Math.random() - 0.5) * 0.5
                );
                
                scene.add(particle);
                
                // Animate and remove particle
                const animateParticle = () => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.y -= 0.05;
                    particle.material.opacity -= 0.02;
                    
                    if (particle.material.opacity > 0) {
                        requestAnimationFrame(animateParticle);
                    } else {
                        scene.remove(particle);
                    }
                };
                
                animateParticle();
            }
        }
        
        function resetBall() {
            ball.position.set(0, 0.22, 0);
            ball.velocity.set(0, 0, 0);
            ball.angularVelocity.set(0, 0, 0);
            player.hasBall = false;
            aiPlayer.hasBall = false;
            
            // Reset player positions
            player.mesh.position.set(-10, 0, 0);
            aiPlayer.mesh.position.set(10, 0, 0);
            
            // Clear trail
            ball.trail = [];
        }
        
        function updateCamera() {
            if (!gameState.isPlaying) return;
            
            const deltaTime = clock.getDelta();
            
            // Calculate target camera position based on mode
            let targetPosition = new THREE.Vector3();
            
            switch(gameState.cameraMode) {
                case 0: // Follow player
                    targetPosition.copy(player.mesh.position).add(cameraOffset);
                    break;
                case 1: // Stadium view
                    targetPosition.copy(cameraOffset);
                    break;
                case 2: // Goal view
                    targetPosition.copy(new THREE.Vector3(0, 10, 45));
                    break;
                case 3: // Side view
                    targetPosition.copy(new THREE.Vector3(40, 15, player.mesh.position.z));
                    break;
            }
            
            // Smooth camera movement
            camera.position.lerp(targetPosition, cameraSmoothness);
            
            // Look at appropriate target
            let lookTarget = new THREE.Vector3();
            switch(gameState.cameraMode) {
                case 0:
                case 3:
                    lookTarget.copy(player.mesh.position);
                    lookTarget.y += 1.5;
                    break;
                case 1:
                    lookTarget.set(0, 0, 0);
                    break;
                case 2:
                    lookTarget.set(0, 0, 0);
                    break;
            }
            
            camera.lookAt(lookTarget);
            
            // Update controls if enabled
            if (controls && !isMobile) {
                controls.update();
            }
        }
        
        function endGame() {
            gameState.isPlaying = false;
            
            const winner = gameState.score.pirates > gameState.score.sundowns ? 'PIRATES' : 
                          gameState.score.pirates < gameState.score.sundowns ? 'SUNDOWNS' : 'DRAW';
            
            setTimeout(() => {
                alert(`GAME OVER!\n\nFinal Score:\nPirates: ${gameState.score.pirates}\nSundowns: ${gameState.score.sundowns}\n\n${winner === 'DRAW' ? "It's a draw!" : `${winner} WIN!`}`);
                
                // Reset game
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('ui').style.display = 'none';
                document.getElementById('stamina-bar').style.display = 'none';
                document.getElementById('pause-btn').style.display = 'none';
                document.getElementById('camera-btn').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                
                // Return to mode selection
                document.getElementById('mode-selection').classList.remove('hidden');
            }, 1000);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            
            if (gameState.isPlaying) {
                updatePlayer();
                updateAI();
                updateBall();
                updateCamera();
            }
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Prevent context menu on mobile
        document.addEventListener('contextmenu', (e) => e.preventDefault());
    </script>
</body>
</html>
